/#
A Kiwi SHA256 implementation inspired by System-Glitch/SHA256: https://github.com/System-Glitch/SHA256

This implementation provides a way to compute the SHA-256 hash of a given input string. It follows the SHA-256 specification outlined in FIPS 180-4.
#/

struct SHA256
  /#
  Initializes a new SHA256 instance, setting up the internal state, constants, and buffers.
  #/
  fn new()
    @K = [
      0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
      0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
      0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
      0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
      0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
      0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
      0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
      0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
      0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
      0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
      0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
      0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
      0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
      0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
      0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
      0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
    ]

    @m_data = [0] * 64
    @m_blocklen = 0
    @m_bitlen = 0
    @m_state = [
      0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, # A, B, C, D,
      0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19  # E, F, G, H
    ]
  end

  /#
  Updates the SHA-256 digest with the provided input data.

  @param data String - The input data to be processed.
  #/
  def update(data)
    length = data.size()
    @m_bitlen += length * 8  # Update the total bit length
    update_data(data.to_bytes(), length)
  end

  /#
  Computes and returns the SHA-256 digest.

  @return List of 32 integers - The computed SHA-256 hash as a list of bytes.
  #/
  fn digest()
    hash = [0] * 32

    pad()
    revert(hash)

    return hash
  end

  /#
  Converts the given digest to a hexadecimal string representation.

  @param digest List of 32 integers - The SHA-256 digest.
  @return String - The hexadecimal string representation of the digest.
  #/
  static fn toString(digest)
    s = ""

    #println "toString(${digest})"

    for i in std::range(0, 31) do
      s += [digest[i]].to_hex()
    end

    return s
  end

  /#
  Performs a right rotation on the given integer value.

  @param x Integer - The value to be rotated.
  @param n Integer - The number of bits to rotate.
  @return Integer - The result of the right rotation.
  #/
  private fn rotr(x, n) 
    return (x >>> n) | (x << (32 - n))
  end
  
  /#
  Chooses between the given integers based on the SHA-256 choose function.

  @param x Integer - The first value.
  @param y Integer - The second value.
  @param z Integer - The third value.
  @return Integer - The result of the choose function.
  #/
  private fn choose(x, y, z)
    return (x & y) ^ (~x & z)
  end

  /#
  Computes the majority of the given integers based on the SHA-256 majority function.

  @param x Integer - The first value.
  @param y Integer - The second value.
  @param z Integer - The third value.
  @return Integer - The result of the majority function.
  #/
  private fn majority(x, y, z)
    return (x & (y | z)) | (y & z) # (x & y) ^ (x & z) ^ (y & z)
  end
  
  /#
  Computes the first round function for the given integer value.

  @param x Integer - The value to be processed.
  @return Integer - The result of the first round function.
  #/
  private fn sigma0(x)
    return rotr(x, 7) ^ rotr(x, 18) ^ (x >>> 3)
  end

  /#
  Computes the second round function for the given integer value.

  @param x Integer - The value to be processed.
  @return Integer - The result of the second round function.
  #/
  private fn sigma1(x)
    return rotr(x, 17) ^ rotr(x, 19) ^ (x >>> 10)
  end

  /#
  Processes the current block of data and updates the state.

  This method is responsible for the main SHA-256 algorithm, applying the necessary transformations
  and updating the state variables.
  #/
  private def transform()
    maj = 0, xorA = 0, ch = 0, xorE = 0, sum = 0, newA = 0, newE = 0, m = [0] * 64
    state = [0] * 8

    # Split data in 32 bit blocks for the first 16 words
    i = 0, j = 0
    while i < 16 do
      m[i] = (@m_data[j] << 24) | (@m_data[j + 1] << 16) | (@m_data[j + 2] << 8) | (@m_data[j + 3])
      i += 1, j += 4
    end

    # Fill remaining 48 blocks
    k = 16
    while k < 64 do
      m[k] = (sigma1(m[k - 2]) + m[k - 7] + sigma0(m[k - 15]) + m[k - 16]) % (1 << 32)
      k += 1
    end

    for i in std::range(0, 7) do
      state[i] = @m_state[i]
    end

    for i in std::range(0, 63) do
      maj  = majority(state[0], state[1], state[2])
      xorA = (rotr(state[0], 2) ^ rotr(state[0], 13) ^ rotr(state[0], 22)) % (1 << 32)
      ch   = choose(state[4], state[5], state[6])
      xorE = (rotr(state[4], 6) ^ rotr(state[4], 11) ^ rotr(state[4], 25)) % (1 << 32)
      sum  = (m[i] + @K[i] + state[7] + ch + xorE) % (1 << 32)
      newA = (xorA + maj + sum) % (1 << 32)
      newE = (state[3] + sum) % (1 << 32)

      # Update state variables
      state[7] = state[6] 
      state[6] = state[5]
      state[5] = state[4]
      state[4] = newE
      state[3] = state[2]
      state[2] = state[1]
      state[1] = state[0]
      state[0] = newA
    end

    for i in std::range(0, 7) do
      @m_state.set(i, (@m_state[i] + state[i]) % (1 << 32))
    end
  end

  /#
  Pads the input data to ensure it meets the requirements for SHA-256 processing.

  This function appends a '1' bit followed by the necessary number of '0' bits
  and appends the length of the original message.
  #/
  private def pad()
    i = 0 + @m_blocklen
    _end = @m_blocklen < 56 ? 56 : 64

    # Append a bit '1'
    @m_data.set(i, 0x80)
    i += 1

    # Pad with zeros
    while i < _end do
      @m_data.set(i, 0x00)
      i += 1
    end

    if @m_blocklen >= 56
      transform()
      for i in std::range(0, 55) do
        @m_data.set(i, 0)
      end
    end

    # Append 64 bits (8 bytes) representing the bit length.
    for i in std::range(0, 7) do
      @m_data.set(56 + i, (@m_bitlen >>> (56 - (i * 8))) & 0xFF)
    end

    transform()
  end


  /#
  Reverts the state and prepares the final hash in big-endian byte order.

  @param hash List of 32 integers - The output array to hold the final hash.
  #/
  private def revert(hash)
    # SHA uses big-endian byte ordering
    # Revert all bytes
    for i in std::range(0, 7) do
      hash[i * 4 + 0] = (@m_state[i] >>> 24) & 0x000000ff
      hash[i * 4 + 1] = (@m_state[i] >>> 16) & 0x000000ff
      hash[i * 4 + 2] = (@m_state[i] >>> 8)  & 0x000000ff
      hash[i * 4 + 3] = (@m_state[i])        & 0x000000ff
    end
  end

  /#
  Updates the internal data buffer with the provided input data.

  @param data List of integers - The input data to be processed.
  @param length Integer - The length of the input data.
  #/
  private def update_data(data, length)
    if length == 0
      pad()
      return
    end

    for i in std::range(0, length - 1) do
      @m_data.set(@m_blocklen, data[i])
      @m_blocklen += 1

      if @m_blocklen == 64
        transform()

        # End of the block
        @m_bitlen += 512
        @m_blocklen = 0
      end
    end
  end
end

fn run_tests()
  build_test_case = with (_input, _expected) do
    return {
      "input": _input,
      "expected": _expected
    }
  end
  
  # Input strings and their expected SHA256 hashes.
  test_cases = [
    build_test_case("Hello, World!", "dffd6021bb2bd5b0af676290809ec3a53191dd81c7f70a4b28688a362182986f"),
    build_test_case("Kiwi Programming Language", "0fa511438c351693a3181371cc0f98fd42dc26f5e605aedab8de84956784784f"),
    build_test_case("", "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"),
    build_test_case(" ", "36a9e7f1c95b82ffb99743e0c5c4ce95d83c9a430aac59f84ef3cbfab6145068"),
    build_test_case("a", "ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807785afee48bb"),
    build_test_case("abc", "ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"),
    build_test_case("string2", "b993212a26658c9077096b804cdfb92ad21cf1e199e272c44eb028e45d07b6e0"),
    build_test_case("string", "473287f8298dba7163a897908958f7c0eae733e25d2e027992ea2edc9bed2fa8"),
    build_test_case("The quick brown fox jumps over the lazy dog.", "ef537f25c895bfa782526529a9b63d97aa631564d5d789c2b765448c8635fb6c")
  ]

  for test_case in test_cases do
    sha = SHA256.new()
    sha.update(test_case.input)
    digest = sha.digest()
    actual = SHA256.toString(digest)

    if actual == test_case.expected
      println "Test passed for input: '${test_case.input}'"
    else
      println "Test failed for input: '${test_case.input}'.\n  Expected: ${test_case.expected},\n  Actual: ${actual}"
    end
  end
end

fn main(args)
  if args.empty()
    return run_tests()
  end

  for arg in args do
    sha = SHA256.new()
    sha.update(arg)
    digest = sha.digest()

    println "input:  '${arg}'"
    println "sha256: ${SHA256.toString(digest)}"
  end
end

main(argv::get())
