# a script for debugging and experimentation (and fun!)

package json
  /#
  Summary: Deserialize a JSON string into runtime objects. Returns `null` when data is malformed.
  Params:
    - s: A string containing JSON data.
  Returns: Any type of data deserialized 
  #/
  fn parse(s)
    # Expect only string input.
    throw std::error::create("JsonError", "Expected a string but got ${s.type()}") when !std::is_string(s)

    try
      # If it is an empty string, return an empty list.
      return [] when s.trim().empty()

      deserialized_value = deserialize(s)
      return deserialized_value
    catch
      println "whoops"
      return null
    end
  end

  /#
  Summary: Returns true if a given string value can be parsed as JSON. 
  Params:
    - s: A string to check.
  Returns: Returns `true` if a given string value can be parsed as JSON. 
  #/
  fn can_parse(s)
    # Expect only string input.
    throw std::error::create("JsonError", "Expected a string but got ${s.type()}") when !std::is_string(s)

    parsed_value = json::parse(s)
    valid_types = [Hash, List, String, Integer, Float, Boolean, None]
    # return parsed_value.type() in valid_types
    return valid_types.contains(parsed_value.type())
  end

  /#
  Summary: Serializes runtime objects to JSON string. Returns `null` when data is malformed.
  Params:
    - data: Any data you want to serialize as JSON.
  Returns: String of JSON data.
  #/
  fn stringify(data)
    try
      return serialize(data)
    catch
      return null
    end    
  end
end

export "json"

/#
json_files = fs::glob("./inputfile*")

for json_file in json_files do
  println "parsing json file: '${json_file}'"
  json = fs::read(json_file)
  println json::parse(json)
  println ""
end
#/

println json::can_parse("hello world {asdf}")