/#
A Kiwi SHA256 implementation inspired by System-Glitch/SHA256: https://github.com/System-Glitch/SHA256
#/

struct SHA256
  fn new()
    @K = [
      0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
      0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
      0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
      0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
      0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
      0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
      0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
      0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
      0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
      0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
      0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
      0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
      0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
      0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
      0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
      0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
    ]

    @m_data = [0] * 64
    @m_blocklen = 0
    @m_bitlen = 0
    @m_state = [
      0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, # A, B, C, D,
      0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19  # E, F, G, H
    ]
  end

  /#
  @param data String
  #/
  def update(data)
	  update_data(data.to_bytes(), data.size())
  end

  /#
  @return List of 32 integers
  #/
  fn digest()
    hash = [0] * 32

    pad()
    revert(hash)

    return hash
  end

  /#
  @param digest List of 32 integers.
  @return String
  #/
  static fn toString(digest)
    s = ""

    for i in std::range(0, 31) do
      s += [digest[i]].to_hex()
    end

    return s
  end

  /#
  @param x Integer
  @param n Integer
  @return Integer
  #/
  private fn rotr(x, n) 
    return (x >>> n) | (x << (32 - n))
  end
  
  /#
  @param e Integer
  @param f Integer
  @param g Integer
  @return Integer
  #/
  private fn choose(e, f, g)
    return (e & f) ^ (~e & g)
  end

  /#
  @param a Integer
  @param b Integer
  @param c Integer
  @return Integer
  #/
  private fn majority(a, b, c)
    return (a & (b | c)) | (b & c)
  end
  
  /#
  @param x Integer
  @return Integer
  #/
  private fn sig0(x)
    return rotr(x, 7) ^ rotr(x, 18) ^ (x >>> 3)
  end

  /#
  @param x Integer
  @return Integer
  #/
  private fn sig1(x)
    return rotr(x, 17) ^ rotr(x, 19) ^ (x >>> 10)
  end

  private def transform()
    maj = 0, xorA = 0, ch = 0, xorE = 0, sum = 0, newA = 0, newE = 0, m = [0] * 64
    state = [0] * 8

    # Split data in 32 bit blocks for the 16 first words
    i = 0, j = 0
    while i < 16 do
      m[i] = (@m_data[j] << 24) | (@m_data[j + 1] << 16) | (@m_data[j + 2] << 8) | (@m_data[j + 3])
      i += 1, j += 4
    end

    # Remaining 48 blocks
    k = 16
    while k < 64 do
      m[k] = (sig1(m[k - 2]) + m[k - 7] + sig0(m[k - 15]) + m[k - 16]) % (1 << 32)
      k += 1
    end

    for i in std::range(0, 7) do
      state[i] = @m_state[i]
    end

    for i in std::range(0, 63) do
      maj  = majority(state[0], state[1], state[2])
      xorA = (rotr(state[0], 2) ^ rotr(state[0], 13) ^ rotr(state[0], 22)) % (1 << 32)
      ch   = choose(state[4], state[5], state[6])
      xorE = (rotr(state[4], 6) ^ rotr(state[4], 11) ^ rotr(state[4], 25)) % (1 << 32)
      sum  = (m[i] + @K[i] + state[7] + ch + xorE) % (1 << 32)
      newA = (xorA + maj + sum) % (1 << 32)
      newE = (state[3] + sum) % (1 << 32)

      state[7] = state[6]
      state[6] = state[5]
      state[5] = state[4]
      state[4] = newE
      state[3] = state[2]
      state[2] = state[1]
      state[1] = state[0]
      state[0] = newA
    end

    for i in std::range(0, 7) do
      @m_state.set(i, (@m_state[i] + state[i]) % (1 << 32))
    end
  end

  private def pad()
    i = 0 + @m_blocklen
    _end = @m_blocklen < 56 ? 56 : 64

    # Append a bit 1
    @m_data.set(i, 0x80)
    i += 1

    # Pad with zeros
    while i < _end do
      @m_data.set(i, 0x00)
      i += 1
    end

    if @m_blocklen >= 56
      transform()
      for i in std::range(0, 55) do
        @m_data.set(i, 0)
      end
    end

    # Append to the padding the total message's length in bits and transform.
    @m_bitlen += @m_blocklen * 8
    
    @m_data.set(63, @m_bitlen)
    @m_data.set(62, @m_bitlen >>> 8)
    @m_data.set(61, @m_bitlen >>> 16)
    @m_data.set(60, @m_bitlen >>> 24)
    @m_data.set(59, @m_bitlen >>> 32)
    @m_data.set(58, @m_bitlen >>> 40)
    @m_data.set(57, @m_bitlen >>> 48)
    @m_data.set(56, @m_bitlen >>> 56)

    transform()
  end

  /#
  @param hash List of 32 integers.
  #/
  private def revert(hash)
    # SHA uses big endian byte ordering
    # Revert all bytes
    for i in std::range(0, 3) do
      for j in std::range(0, 7) do
        hash[i + (j * 4)] = (@m_state[j] >>> (24 - i * 8)) & 0x000000ff
      end
    end
  end

  /#
  @param data List of integers
  @param length Integer
  #/
  private def update_data(data, length)
    for i in std::range(0, length -1) do
      @m_data.set(@m_blocklen, data[i])
      @m_blocklen += 1

      if @m_blocklen == 64
        transform()

        # End of the block
        @m_bitlen += 512
        @m_blocklen = 0
      end
    end
  end
end

fn main(args)
  for arg in args do
    sha = SHA256.new()
    sha.update(arg)
    digest = sha.digest()

    println "input:  '${arg}'"
    println "sha256: ${SHA256.toString(digest)}"
  end
end

main(argv::get())