# For experimentation and fun.

println "Running Debug Tests ...\n"

guava::register_test("debug", with () do
  println "\n\n"
  /# 
  test assertions like so:
    guava::assert(1 == 1, "One should equal one.")
  #/
  
  # write your code below this line.

  fn parse_yaml(yaml_s)
    iter = StringIterator.new(yaml_s + "\n")
    yaml_root = {}

    while iter.can_read() do
      c = iter.current()

      if c == "\n"
        iter.consume()
      elsif c == "#"
        parse_yaml_comment(iter)
      else
        yaml_key = parse_yaml_key(iter).clone()
        yaml_value = parse_yaml_value(iter)
        yaml_root[yaml_key.trim()] = yaml_value.clone()
      end
    end

    return yaml_root
  end

  fn parse_yaml_structure(iter, nest = false)
    struct = {}
    fallout = false

    while iter.can_read() && iter.current() != "\n" do
      break when fallout
      c = iter.current()

      if c == "#"
        parse_yaml_comment(iter)
      else
        tmp_struct_key = parse_yaml_key(iter).trim()

        if iter.look_ahead() == "\n"
          iter.skip_whitespace()
          iter.consume()

          if nest
            fallout = true
          end
        end

        if iter.look_ahead() == "-"
          pre_parse_level = iter.count_ahead()
          tmp_struct_value = parse_yaml_list(iter)
          if pre_parse_level != iter.count_ahead
            struct[tmp_struct_key] = tmp_struct_value
          end
        else
          tmp_struct_value = parse_yaml_value(iter)
          struct[tmp_struct_key] = tmp_struct_value
        end
        
        if !fallout
          # handle next property
          if iter.current() == "\n" && iter.peek() == " "
            iter.consume()
          end

          if iter.look_ahead() == "-"
            fallout = true
          end
        end
      end
    end

    return struct.clone()
  end

  fn parse_yaml_list_value(iter)
    list_value = ""
    
    if iter.current() == "-"
      iter.consume() # skip the "-"
      iter.skip_whitespace()
    end

    if iter.current() != "#"
      list_value = parse_yaml_value(iter)
      
      if iter.current() == "\n"
        iter.consume()
      end
    end

    return list_value
  end

  fn parse_yaml_list(iter)
    tmp_list = []
    level = iter.count_ahead()
    iter.skip_whitespace()

    while iter.can_read() && iter.current() == "-" do
      tmp_list_value = parse_yaml_list_value(iter)
      tmp_list.push(tmp_list_value)

      if iter.count_ahead() != level
        println "breaking count ahead: " + iter.count_ahead()
        println "breaking look ahead:  '" + iter.look_ahead() + "'"
        println "tmp_list: " + tmp_list.to_string()
      end
      break when iter.count_ahead() != level

      # handle next item
      if iter.look_ahead() == "-"
        iter.skip_whitespace()
      end
    end
    
    res_list = tmp_list.clone()
    tmp_list.clear()
    return res_list
  end

  fn parse_yaml_multiline_string(iter)
    if iter.current() == "|"
      iter.consume() 
    end

    if iter.current() == "\n"
      iter.consume()
    end

    multiline_value = ""

    while iter.current() == " " && iter.peek() == " " do
      iter.skip_whitespace()

      while iter.current() != "\n" do
        # should we allow "#" in a multiline string?
        if iter.current() == "#"
          parse_yaml_comment(iter)
        end

        multiline_value += iter.current()
        iter.consume()
      end

      iter.consume() # skip newline
      multiline_value += " " # add a space
    end

    return multiline_value.trim()
  end

  fn parse_yaml_string(iter, quote_type)
    if iter.current() == quote_type
      iter.consume()
    end

    value = ""
    
    while iter.current() != quote_type do
      value += iter.current()
      iter.consume()
    end

    return value.trim()
  end

  fn parse_yaml_literal(iter)
    value = iter.current()
    iter.consume()
    
    while iter.current() != "\n" do
      value += iter.current()
      iter.consume()
    end

    if value == "true" || value == "True"
      value = true
    elsif value == "false" || value == "False"
      value = false
    elsif value == "null" || value == "Null"
      value = null
    elsif value.contains(": ")
      iter.rewind(value.size())
      value = parse_yaml_structure(iter, true).clone()
    end
    
    return value
  end

  fn parse_yaml_numeric_literal(iter)
    value = iter.current()
    iter.consume()
    
    while iter.current() != "\n" do
      value += iter.current()
      iter.consume()
    end

    if value.contains(".") && value.count(".") > 1
      return value
    elsif value.contains("-") && (value.count("-") > 1 || !value.begins_with("-"))
      return value
    elsif value.contains(".")
      return value.to_double()
    else
      return value.to_int()
    end
  end

  fn parse_yaml_comment(iter)
    while iter.can_read() && iter.current() != "\n" do
      iter.consume()
    end
    iter.consume() # Skip the newline
  end

  fn parse_yaml_key(iter)
    key = ""

    while iter.current() != ":" do
      key += iter.current()
      iter.consume()
    end

    iter.consume() # skip ":"
    iter.skip_whitespace()

    return key
  end

  fn parse_yaml_value(iter)
    ic = iter.current()

    if ic == "\n" && iter.peek() == " "
      if ic == "\n"
        iter.consume() # Skip newline
      end
      
      next_c = iter.look_ahead()

      if next_c == "-"
        return parse_yaml_list(iter)
      else
        return parse_yaml_structure(iter)
      end
    elsif ic == "|"
      return parse_yaml_multiline_string(iter)
    elsif next_c == "\"" || next_c == "'"
      return parse_yaml_string(iter, next_c)
    elsif string::isnumeric(ic) || ["-", "."].contains(ic)
      return parse_yaml_numeric_literal(iter)
    else
      return parse_yaml_literal(iter)
    end
  end

  yml = "
# Basic key-value pairs
name: Kiwi
version: 2.0.3
release_date: 2024-09-01
description: |
  Kiwi is a fast and flexible scripting language
  designed for high-performance computing and easy integration
  with modern systems.

# List of items
supported_platforms:
  - Linux
  - macOS
  - Windows

# Nested structure (map within map)
author:
  name: Scott \"Scotty\" Stauffer
  email: scott@fuseraft.com
  website: https://fuseraft.com

# Boolean values
active: true

# Null value
deprecated_features: null

# Integers and floats
build_number: 1001
average_speed: 3.14159

# Mixed data types in a list
features:
  - type: core
    description: High-speed interpreter
    status: active
  - type: plugin
    description: YAML parser for config files
    status: planned

# Nested list
release_history:
  - version: 0.9.0
    date: 2023-05-15
    changes:
      - Added basic interpreter functions
      - Improved memory management
  - version: 1.0.0
    date: 2024-11-01
    changes:
      - Official release
      - Added machine learning library
      - Added YAML parser"

/#
  yml = "
fruits:
  - - apple
    - banana
    - cherry
  - - orange
    - grape
    - watermelon
  - - mango
    - pineapple
    - peach
"#/
  
  res = parse_yaml(yml)
  println res.pretty()

  # write your code above this line.
  println "\n"
end)

fn run_tests()
  results = guava::run_tests()
  
  succeeded = 0
  failed = 0
  duration = 0
  
  for r in results do
    duration += r.duration
    
    if r.result
      succeeded += 1
    else
      failed += 1
    end
  end
  
  println "\nRan ${results.size()} test(s) in ${duration}ms\n"
  
  if failed == 0
    println "All tests passed!"
  else
    println "${succeeded} tests passed, ${failed} tests failed."
  end
end

run_tests()