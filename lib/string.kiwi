require "path"

/#
A package with interesting string operations.
#/
package string
  struct StringIterator
    fn new(s)
      @chars = s.chars()
      @len = @chars.size()
      @pos = 0
    end

    fn consume()
      @pos += 1
    end

    fn skip(n)
      if @pos + n < @len
        @pos = @len
      else
        @pos += n
      end
    end

    fn can_read()
      (@pos + 1 < @len)
    end

    fn current()
      if @pos < @len
        return @chars.get(@pos)
      end
      
      ""
    end

    fn peek()
      if @pos + 1 < @len
        return @chars.get(@pos + 1)
      end

      ""
    end

    fn position()
      @pos
    end

    fn length()
      @len
    end

    fn rewind(n)
      @pos -= n
    end

    fn grab(n)
      if n < @len && n >= 0
        return @chars.get(n)
      end
      ""
    end

    fn reach(n)
      if @len + n < @len && @len + n >= 0
        return @chars.get(@len + n)
      end
      ""
    end

    fn look_ahead()
      return "" when !can_read()
      tmp_chars = []

      try
        tmp_chars = (@chars)[@pos: :]
      end

      c = tmp_chars.get(i)
      i = 0

      while c == " " && i + 1 < tmp_chars.size() do
        c = tmp_chars.get(i)
        i += 1
      end

      c
    end

    fn count_ahead()
      return 0 when !can_read()
      tmp_chars = []

      try
        tmp_chars = (@chars)[@pos: :]
      end

      c = tmp_chars.get(i)
      i = 0

      while c == " " && i + 1 < tmp_chars.size() do
        c = tmp_chars.get(i)
        i += 1
      end

      i - 1
    end

    fn skip_whitespace()
      while can_read() && current() == " " do
        consume()
      end
    end
  end

  /#
  @summary Returns `true` if `str` contains any values in `matches`.
  @param   String  str      : The input string. 
  @param   List    matches  : The strings to match against. 
  @return  Boolean          : True if found.
  #/
  fn contains_any(str, matches = [])
    matches = matches.chars() when matches.type() == "string"
    throw "matches must be a list" when matches.type() != "list"

    for m in matches do
      if str.contains(m)
        return true
      end
    end

    false
  end

  /#
  @summary Encodes a string as a base64 string.
  @param   String  _input   : The input string. 
  @return  String           : The base64 encoded string.
  #/
  fn base64encode(_input)
    __base64encode__("${_input}")
  end

  /#
  @summary Decodes a base64 string to plaintext.
  @param   String  _input   : The input string. 
  @return  String           : The plaintext string.
  #/
  fn base64decode(_input)
    __base64decode__("${_input}")
  end

  /#
  @summary Encodes a string as a URL encoded string.
  @param   String  _input   : The input string.
  @return  String           : The URL encoded string.
  #/
  fn urlencode(_input)
    __urlencode__("${_input}")
  end

  /#
  @summary Decodes a URL encoded string to plaintext.
  @param   String  _input   : The input string. 
  @return  String           : The plaintext string.
  #/
  fn urldecode(_input)
    __urldecode__("${_input}")
  end

  /#
  @summary Pads the left side of a string.
  @param   String  _input   : The input string. 
  @param   Integer _size    : The max length of the output string.
  @param   String  _padding : The padding content.
  @return  String           : The padded string.
  #/
  fn padstart(_input, _size, _padding = " ")
    return "${_input}" when ("${_input}").size() >= _size
    _padding = " " when _padding.size() != 1
    _padding_size = _size - ("${_input}").size()
    _pad = _padding * _padding_size
    _pad + "${_input}"
  end

  /#
  @summary Pads the right side of a string.
  @param   String  _input   : The input string. 
  @param   Integer _size    : The max length of the output string.
  @param   String  _padding : The padding content.
  @return  String           : The padded string.
  #/
  fn padend(_input, _size, _padding = " ")
    return "${_input}" when ("${_input}").size() >= _size
    _padding = " " when _padding.size() != 1
    _padding_size = _size - ("${_input}").size()
    _pad = _padding * _padding_size
    "${_input}" + _pad
  end

  /#
  @summary Centers a string within a given width.
  @param   String  _input   : The input string.
  @param   Integer _width   : The width of the resulting string.
  @param   String  _padding : The padding character (default is space).
  @return  String           : The centered string.
  #/
  fn center(_input, _width, _padding = " ")
    return "${_input}" when ("${_input}").size() >= _width
    _padding = " " when _padding.size() != 1
    _total_padding = _width - ("${_input}").size()
    _left_padding_size = _total_padding / 2
    _right_padding_size = _total_padding - _left_padding_size
    _left_pad = _padding * _left_padding_size
    _right_pad = _padding * _right_padding_size
    _left_pad + ("${_input}") + _right_pad
  end

  /#
  @summary Repeats each character in the string a specified number of times.
  @param   String  _input : The input string.
  @param   Integer _count : The number of times each character is repeated.
  @return  String         : The string with characters echoed.
  #/
  fn echo(_input, _count)
    _output = ""
    for char in ("${_input}").chars() do
      _output = _output + (char * _count)
    end
    _output
  end

  /#
  @summary Interweaves characters from two strings.
  @param   String  _input1 : The first input string.
  @param   String  _input2 : The second input string.
  @return  String          : The interwoven string.
  #/
  fn interweave(_input1, _input2)
    _output = ""
    _length = [("${_input1}").size(), ("${_input2}").size()].max()
    for i in [0 to _length - 1] do
      _output = _output + ("${_input1}")[i] when i < ("${_input1}").size()
      _output = _output + ("${_input2}")[i] when i < ("${_input2}").size()
    end
    _output
  end

  /#
  @summary Creates a mirrored version of the input string.
  @param   String  _input    : The input string.
  @param   String  _delimiter: The delimiter to separate the original string from its mirror.
  @return  String            : The mirrored string.
  #/
  fn mirror(_input, _delimiter = "")
    ("${_input}") + _delimiter + ("${_input}").reverse()
  end

  /#
  @summary Randomly shuffles the characters in a string.
  @param   String  _input : The input string.
  @return  String         : The shuffled string.
  #/
  fn shuffle(_input)
    _array = ("${_input}").chars()
    _n = _array.size()
    
    while _n > 1 do
      _n = _n - 1
      _k = __random__(0, _n)
      _array.swap(_k, _n)
    end

    _array.join("")
  end

  /#
  @summary Generates a URL-friendly slug from a string.
  @param   String  _input   : The input string.
  @return  String           : The generated slug.
  #/
  fn slug(_input)
    _lowercased = ("${_input}").lowercase()
    _hyphenated = _lowercased.replace(" ", "-")

    _slug = ""

    for char in _hyphenated.chars() do
      if char.is_a(integer) || (char >= "a" && char <= "z") || char == "-"
        _slug += char
      end
    end

    _slug
  end
  
  /#
  @summary Returns a copy of the string with the first character uppercased and the rest lowercased.
  @param   String  _input   : The input string.
  @return  String           : The capitalized string.
  #/
  fn capitalize(_input: string): string
    return "" when _input.empty()
    
    first = _input[0].uppercase()
    rest = _input[1:].lowercase()
    first + rest
  end

  fn capitalise(_input: string): string
    _input.capitalize()
  end

  /#
  @summary Returns a copy of the string with the first character of every word uppercased and the rest lowercased.
  @param   String  _input   : The input string.
  @return  String           : The capitalized string.
  #/
  fn titleize(_input: string): string
    return "" when _input.empty()
    
    # Split on whitespace, capitalize each non-empty word, join back
    words = _input.rsplit('\s+').filter(with (w) do not w.empty() end)
    words.map(with (word) do word.capitalize() end).join(" ")
  end

  fn title(s: string): string
    s.titleize()
  end

  fn smart_titleize(
    s: string, 
    keep_lowercase: list = ["a", "an", "and", "but", "by", "for", "in", "nor", "of", "on", "or", "the", "to", "with"]
  ): string
    words = s.rsplit('\s+').filter(with (w) do not w.empty() end)
    
    result = []
    
    for i, word in words do
      lowered = word.lowercase()
      
      # First word always capitalized or small words that are NOT in the exception list
      if i == 0 or not keep_lowercase.contains(lowered)
        result.push(word.capitalize())
      else
        result.push(lowered)
      end
    end
    
    result.join(" ")
  end

  /#
  @summary Checks if the string consists only of numeric characters.
  @param   String  _input : The input string.
  @return  Boolean        : True if the string is numeric, otherwise false.
  #/
  fn isnumeric(_input): boolean
    _isnumeric = true
    
    for char in ("${_input}").chars() do
      if !(char >= "0" && char <= "9")
        _isnumeric = false
        break
      end
    end

    _isnumeric
  end

  /#
  @summary Checks if the string consists only of alphabetic characters.
  @param   String  _input : The input string.
  @return  Boolean        : True if the string is alphabetic, otherwise false.
  #/
  fn isalpha(_input)
    for char in ("${_input}").chars() do
      if !((char >= "a" && char <= "z") || (char >= "A" && char <= "Z"))
        return false
      end
    end

    true
  end

  /#
  @summary Checks if the string consists only of alphanumeric characters.
  @param   String  _input : The input string.
  @return  Boolean        : True if the string is alphanumeric, otherwise false.
  #/
  fn isalphanumeric(_input)
    for char in ("${_input}").chars() do
      if !(char >= "0" && char <= "9" || (char >= "a" && char <= "z") || (char >= "A" && char <= "Z"))
        return false
      end
    end

    true
  end

  /#
  @summary Checks if the string is entirely in uppercase.
  @param   String  _input   : The input string.
  @return  Boolean          : True if the string is all uppercase, false otherwise.
  #/
  fn isupper(_input)
    for char in ("${_input}").chars() do
      # If any character is lowercase, return false
      if char >= "a" && char <= "z"
        return false
      end
    end
    true
  end

  /#
  @summary Checks if the string is entirely in lowercase.
  @param   String  _input   : The input string.
  @return  Boolean          : True if the string is all lowercase, false otherwise.
  #/
  fn islower(_input)
    for char in ("${_input}").chars() do
      # If any character is uppercase, return false
      if char >= "A" && char <= "Z"
        return false
      end
    end
    true
  end

  /#
  @summary Converts all characters in the string to uppercase.
  @param   String  _input   : The input string.
  @return  String           : The string converted to uppercase.
  #/
  fn toupper(_input)
    ("${_input}").uppercase()
  end

  /#
  @summary Converts all characters in the string to lowercase.
  @param   String  _input   : The input string.
  @return  String           : The string converted to lowercase.
  #/
  fn tolower(_input)
    ("${_input}").lowercase()
  end

  /#
  @summary Remove common leading whitespace from multi-line strings
  @param   String text : The input string
  @return  String      : The dedented string.
  #/
  fn dedent(text: string): string
    lines = text.lines()

    # Remove empty first line if it exists (common in multi-line strings)
    if lines.size() > 0 && lines[0].trim().empty()
      lines = lines[1:]
    end

    # Find minimum indentation (ignore blank lines)
    min_indent = 999999
    for line in lines do
      trimmed = line.ltrim()
      if !trimmed.empty() && line.size() > trimmed.size()
        indent = line.size() - trimmed.size()
        min_indent = [indent, min_indent].min()
      end
    end

    # If no indentation found, return as-is
    if min_indent == 999999
      return text
    end

    # Remove common indent from each line
    result = []
    for line in lines do
      if line.size() >= min_indent
        result.append(line[min_indent:])
      else
        result.append(line)  # shouldn't happen, but safe
      end
    end

    # Join and restore final newline if original had one
    output = result.join("\n")
    text.ends_with("\n") ? output + "\n" : output
  end

  /#
  @summary Gives the string type a function that returns itself as an instance of Path.
  @param   string path : The path.
  @return  Path        : The path as a Path.
  #/
  fn to_path(path: string): Path
    Path.new(path)
  end
end