/# An implementation for working with sets. #/

struct Set
  fn new(data = [])
    @data = data.unique()
  end

  fn add(item)
    new_data = (@data).clone()
    new_data.push(item)
    @data = new_data.flatten().unique()
  end

  fn remove(item)
    new_data = to_list().select(with (n) do return n != item end)
    @data = new_data
  end

  fn contains(item)
    return to_list().contains(item)
  end

  fn size()
    return to_list().size()
  end

  fn clear()
    @data = []
  end

  fn difference(data)
    input_data = get_input_data(data)
    new_data = to_list()
    return Set.new(new_data.select(with (n) do return !input_data.contains(n) end))
  end

  fn disjoint(data)
    return !intersect(data)
  end

  fn intersect(data)
    input_data = get_input_data(data)
    new_data = to_list()
    return !new_data.select(with (n) do return input_data.contains(n) end).empty()
  end

  fn merge(data)
    input_data = get_input_data(data)
    new_data = to_list()
    new_data.push(input_data)
    @data = new_data.flatten().unique()
  end

  fn union(data)
    input_data = get_input_data(data)
    new_data = to_list()
    new_data.push(input_data)
    return Set.new(new_data.flatten())
  end

  fn subset(data)
    input_data = get_input_data(data)
    new_data = to_list()
    return input_data.select(with (n) do return new_data.contains(n) end).size() == new_data.size()
  end

  fn superset(data)
    input_data = get_input_data(data)
    new_data = to_list()
    return input_data.select(with (n) do return new_data.contains(n) end).size() == input_data.size()
  end

  fn to_list()
    return ((@data).clone())
  end

  fn to_string()
    return to_list().to_string()
  end

  fn type()
    return "Set"
  end

  private fn get_input_data(data)
    input_data = []
    if data.type() == "Set"
      input_data = data.to_list()
    elsif data.is_a(List)
      input_data = data
    else
      throw "Expected a List or a Set."
    end
    return input_data
  end
end
