/#
@summary The __global__ file contains global definitions.
#/

const KIWI_STDLIB_VERSION = "1.3.7"

const STDLIB_PACKAGES = [
  "hashable", "compress", "console", "crypto", "csv",
  "env", "fio", "http", "iter", "list", "path", "math", "socket", "tls",
  "std", "std::error", "stdin", "string", "sys", "task", "tester", "time",
]

for pkg in STDLIB_PACKAGES do
  export pkg
end

/#
@summary Easy access to the date type.
#/
fn d
(
  year:         any     = time::now().to_string(),
  month:        integer = 1,
  day:          integer = 1,
  hour:         integer = 0,
  minute:       integer = 0,
  second:       integer = 0,
  millisecond:  integer = 0
): date
  return year.to_date() when year.is_a(string)

  var
  (
    y:          string = "${year}",
    m:          string = ("${month}").padstart(2, "0"),
    d:          string = ("${day}").padstart(2, "0"),
    h:          string = ("${hour}").padstart(2, "0"),
    mi:         string = ("${minute}").padstart(2, "0"),
    s:          string = ("${second}").padstart(2, "0"),
    ms:         string = ("${millisecond}").padstart(3, "0")
  )

  ("${y}/${m}/${d} ${h}:${mi}:${s}.${ms}").to_date()
end

/#
Returns a unicode character without requiring escaping.

Usage:
```kiwi
println char(0x1F95D)          # ğŸ¥
println char("U+1F40D")        # ğŸ
println char(0x2764)           # â¤ï¸
println char(0x25A0)           # â–  
println char("1F600")          # ğŸ˜Š
```
#/
fn char(code)
  # code can be integer or hex string
  if code.is_a(integer)
    hex = code.to_hex().padstart(8, "0").uppercase()
  else
    hex = code.uppercase().trim().replace("0x", "").replace("U+", "")
    if hex.size() < 4
      hex = hex.padstart(4, "0")
    elsif hex.size() > 8
      hex = hex[hex.size()-8:]  # truncate to last 8 digits
    end
  end
    
  hex = hex.size() < 8 ? hex.padstart(8, "0") : hex

  code_str = "\"\\U${hex}\""  
  lambda_str = "(with () do ${code_str} end)()"

  # I know.
  eval(lambda_str)
end

/#
Awaits a task.
#/
fn await(task_id: integer)
  task::await(task_id)
end

/#
Spawns a task.
#/
fn spawn(callback: lambda, args: list = [])
  task::spawn(callback, args)
end

fn input(msg: string = "")
  __console_readline__()
end

/#
Used to check if the script is the entrypoint.
#/
fn __main__(): boolean
  __entrypath__() == __execpath__()
end