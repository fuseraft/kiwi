/#
@summary The __global__ file contains global definitions.
#/

const KIWI_STDLIB_VERSION = "1.3.6"

/#
A generally useful struct. 

When inherited, structs receive a to_hash() function that returns their instance variables as a hashmap.
#/
struct Hashable
  fn to_hash(): hashmap
    (@).keys().reduce({}, do (acc, k) => acc[k] = (@).get(k))
  end
end

/#
@summary Easy access to the date type.
#/
fn d
(
  year:         any     = time::now().to_string(),
  month:        integer = 1,
  day:          integer = 1,
  hour:         integer = 0,
  minute:       integer = 0,
  second:       integer = 0,
  millisecond:  integer = 0
) #: date
  return year.to_date() when year.is_a(string)

  var
  (
    y:          string = year.to_string(),
    m:          string = string::padstart(month.to_string(), 2, "0"),
    d:          string = string::padstart(day.to_string(), 2, "0"),
    h:          string = string::padstart(hour.to_string(), 2, "0"),
    mi:         string = string::padstart(minute.to_string(), 2, "0"),
    s:          string = string::padstart(second.to_string(), 2, "0"),
    ms:         string = string::padstart(millisecond.to_string(), 3, "0"),
    date_part:  string = "${y}/${m}/${d}",
    time_part:  string = "${h}:${mi}:${s}.${ms}",
    new_date:   date   = ("${date_part} ${time_part}").to_date()
  )

  return new_date
end

/#
Returns a unicode character without requiring escaping.

Usage:
```kiwi
println char(0x1F95D)          # ğŸ¥
println char("U+1F40D")        # ğŸ
println char(0x2764)           # â¤ï¸
println char(0x25A0)           # â–  
println char("1F600")          # ğŸ˜Š
```
#/
fn char(code)
  # code can be integer or hex string
  if code.is_a(integer)
    hex = code.to_hex().padstart(8, "0").uppercase()
  else
    hex = code.uppercase().trim().replace("0x", "").replace("U+", "")
    if hex.size() < 4
      hex = hex.padstart(4, "0")
    elsif hex.size() > 8
      hex = hex[hex.size()-8:]  # truncate to last 8 digits
    end
  end
    
  hex = hex.size() < 8 ? hex.padstart(8, "0") : hex

  code_str = "\"\\U${hex}\""  
  lambda_str = "(with () do ${code_str} end)()"

  eval(lambda_str)
end

/#
Awaits a task.
#/
fn await(task_id: integer)
  task::await(task_id)
end

/#
Spawns a task.
#/
fn spawn(callback: lambda, args: list = [])
  task::spawn(callback, args)
end

/#
Used to check if the script is the entrypoint.
#/
fn __main__(): boolean
  __entrypath__() == __execpath__()
end

/#
I wanted a pathlib-like experience in kiwi.
#/
struct Path < Hashable
  fn new(path: string)
    # wip: path is not collapsed (which is fine for now)
    @path = path
  end

  fn combine(new_path): Path
    var (paths: list = [@path, Path.path_string(new_path)])
    Path.new(fio::combine(paths))
  end

  fn contains(path_part: string): boolean
    parts().contains(path_part)
  end

  fn exists(): boolean
    var (path: string = @path)
    fio::exists(path)
  end

  fn find(path_part: string): Path
    var (path: string = @path)
    find_path = Path.new(path)
    while find_path.name() != path_part do
      find_path = find_path.parent()
    end
    find_path
  end

  fn is_dir(): boolean
    var (path: string = @path)
    fio::isdir(path)
  end

  fn is_file(): boolean
    var (path: string = @path)
    fio::isfile(path)
  end

  fn joinpath(path_parts: list): Path
    var (path: string = @path)
    Path.new(
      fio::combine(
        [path].concat(
          path_parts.map(do (part) => Path.path_string(part))
        )
      )
    )
  end

  fn name(): string
    parts().last()
  end

  fn parent(): Path
    var (path: string = @path)
    Path.new(fio::parentdir(path))
  end

  fn parents(): list
    var (find_root: Path = (@).clone(), found: boolean = false, paths: list = [])
    while not found do
      try
        find_root = find_root.parent()
        paths.push(find_root.clone())
      catch
        found = true
      end
    end
    paths
  end

  fn parts(): list
    var (path: string = @path)
    fio::pathparts(path)
  end

  fn root(): Path
    var (find_root: Path = (@).clone(), found: boolean = false)
    while not found do
      try
        find_root = find_root.parent()
      catch
        found = true
      end
    end
    find_root
  end

  fn to_string(): string
    "${@path}"
  end

  fn /(new_path): Path
    combine(new_path)
  end

  static fn path_string(new_path): string
    new_path.is_a("Path") ? new_path.path : new_path
  end
end

# gives strings a to_path() method that turns them into instances of Path
package string
  fn to_path(path: string): Path
    Path.new(path)
  end
end

export "string"