/# ==============================================================================
    A pretty comprehensive list test. Kiwi's ability to work with list-like data
    is its meat and potatoes so-to-speak.
   ============================================================================== #/
tester::register_test("lists", with do
  # Basic List Operations
  basic_list = [1, 2, 3]
  tester::assert(basic_list.size() == 3, "List size check")
  tester::assert(basic_list[0] == 1, "List element access 0 index")
  tester::assert(basic_list[1] == 2, "List element access 1 index")
  tester::assert(basic_list[2] == 3, "List element access 2 index")

  basic_list.push(4)
  tester::assert(basic_list.size() == 4 and basic_list.sum() == 10, "List insertion")

  other_list = [5, 6, 7]
  combined_list = basic_list.concat(other_list)
  tester::assert(combined_list.size() == 7 and combined_list.sum() == 28, "List concatenation")

  words = ["The", "Kiwi", "Programming", "Language"]
  tester::assert(words.join(" ") == "The Kiwi Programming Language", "List joining with non-empty string")
  tester::assert(words.join("") == "TheKiwiProgrammingLanguage", "List joining on empty string")
  tester::assert(words.join() == "TheKiwiProgrammingLanguage", "List joining default param")

  sliced_list = combined_list[2:5]
  tester::assert(sliced_list.size() == 3 and sliced_list.sum() == 12, "List slicing")

  reversed_list = combined_list[::-1]
  tester::assert(reversed_list.size() == 7 and reversed_list.first() == 7 and reversed_list.sum() == 28, "List reversal")

  nested_list = [1, 2, [3, 4], [5, [6, 7]]].flatten()
  tester::assert(nested_list.size() == 7 and nested_list.sum() == 28, "Nested lists and flattening")

  char_list = "abcdef".chars().reverse()
  tester::assert(char_list.join() == "fedcba", "String to list conversion and manipulation")

  # Empty List Verification
  new_list = []
  
  while not char_list.empty() do
    new_list.push(char_list.first())
    char_list.remove_at(0)
  end

  tester::assert(char_list.empty(), "Expected an empty list")
  tester::assert(new_list.join() == "fedcba", "Expected new list in reverse order")

  range_list = [1 to 5]
  tester::assert(range_list.size() == 5 and range_list.sum() == 15, "List initialization with a range")

  a = [1 to 10]
  b = a.filter(with (i) do i % 2 == 0 end)
  c = a - b
  d = []
  d += b
  d += c

  tester::assert(d.to_string() == "[2, 4, 6, 8, 10, 1, 3, 5, 7, 9]", "General list ops")

  # lists library
  var (fruits: list = [
    { id: 0, name: "apple",  price: 0.75, qty: 100 },
    { id: 1, name: "banana", price: 0.25, qty: 50  }, 
    { id: 2, name: "mango",  price: 1.00, qty: 30  }, 
    { id: 3, name: "banana", price: 0.25, qty: 50  }, 
    { id: 4, name: "kiwi",   price: 0.50, qty: 70, favorite: true }
  ])

  tester::assert(lists::is_unique(fruits.map(with (fruit) do fruit.name end)) == false, "is_unique -> false")
  tester::assert(lists::is_unique(fruits.map(with (fruit) do fruit.name end).unique()) == true, "is_unique -> true")
  tester::assert(lists::find(fruits, with (fruit) do fruit.name == "banana" end) == 1, "find(banana) -> 1")
  tester::assert(lists::find(fruits, with (fruit) do fruit.name == "mango" end) == 2, "find(mango) -> 2")
  tester::assert(lists::first_where(fruits, with (fruit) do fruit.name == "banana" end).id == 1, "first_where(banana) -> 1")
  tester::assert(lists::last_where(fruits, with (fruit) do fruit.name == "banana" end).id == 3, "last_where(banana) -> 3")
  tester::assert(lists::all(fruits, with (fruit) do fruit.has_key("id") end) == true, "all(has_key(id)) -> true")
  tester::assert(lists::all(fruits, with (fruit) do fruit.has_key("favorite") end) == false, "all(has_key(favorite)) -> false")
  tester::assert(lists::_any(fruits, with (fruit) do fruit.has_key("favorite") end) == true, "_any(has_key(favorite)) -> true")
  tester::assert(lists::_any(fruits, with (fruit) do fruit.has_key("foobar") end) == false, "_any(has_key(foobar)) -> false")
  tester::assert(lists::_none(fruits, with (fruit) do fruit.has_key("favorite") end) == false, "_none(has_key(favorite)) -> false")
  tester::assert(lists::_none(fruits, with (fruit) do fruit.has_key("foobar") end) == true, "_none(has_key(foobar)) -> true")
  tester::assert(lists::one(fruits, with (fruit) do fruit.has_key("favorite") end) == true, "one(has_key(favorite)) -> true")
  tester::assert(lists::one(fruits, with (fruit) do fruit.has_key("id") end) == false, "one(has_key(id)) -> false")
  tester::assert(lists::_count(fruits, with (fruit) do fruit.has_key("favorite") end) == 1, "_count(has_key(favorite)) -> 1")
  tester::assert(lists::_count(fruits, with (fruit) do fruit.has_key("foobar") end) == 0, "_count(has_key(foobar)) -> 0")
  tester::assert(lists::index_of(fruits.map(with (fruit) do fruit.name end), "banana") == 1, "index_of(banana) -> 1")
  tester::assert(lists::last_index_of(fruits.map(with (fruit) do fruit.name end), "banana") == 3, "last_index_of(banana) -> 3")
  tester::assert(lists::reject(fruits, with (fruit) do fruit.id < 4 end).first().name == "kiwi", "reject(id < 4) -> kiwi")
  tester::assert(lists::sum_float(fruits.map(with (fruit) do fruit.price end)) == 2.75, "sum_float() -> 2.75")
  tester::assert(lists::sum_integer(fruits.map(with (fruit) do fruit.qty end)) == 300, "sum_integer() -> 300")
end)